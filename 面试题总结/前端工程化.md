## 前端工程化

### 零、对前端工程化的理解

<img src="C:\Users\SFONE\AppData\Roaming\Typora\typora-user-images\image-20220805171058905.png" alt="image-20220805171058905" style="zoom: 50%;" />

<img src="C:\Users\SFONE\AppData\Roaming\Typora\typora-user-images\image-20220805171756827.png" alt="image-20220805171756827" style="zoom: 50%;" />

首先，工程化不等于某个工具

**1.定义**：

前端工程化就是通过各种工具和技术，提升前端开发效率的过程

- 前端工程化的内容：各种工具和技术
- 前端工程化的作用：通过使用工具，提升开发效率

**2.解决的问题：**

- 项目上线前，压缩代码
- 对ES6+或css3新特性进行转换
- 对Less等CSS的预编译语言进行编译处理
- 格式化代码等等

<img src="C:\Users\SFONE\AppData\Roaming\Typora\typora-user-images\image-20220805171831557.png" alt="image-20220805171831557" style="zoom:50%;" />

### 一. 模块化

#### 1.什么是模块？

- 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起
- 块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信

#### 2.模块化的进化过程

- **全局function模式 : 将不同的功能封装成不同的全局函数**

  - 编码: 将不同的功能封装成不同的全局函数
  - 问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系

  - ```js
    function m1(){
      //...
    }
    function m2(){
      //...
    }
    ```

- **namespace模式 : 简单对象封装**

  - 作用: 减少了全局变量，解决命名冲突

  - 问题: 数据不安全(外部可以直接修改模块内部的数据)

  - ```js
    let myModule = {
      data: 'www.baidu.com',
      foo() {
        console.log(`foo() ${this.data}`)
      },
      bar() {
        console.log(`bar() ${this.data}`)
      }
    }
    myModule.data = 'other data' //能直接修改模块内部的数据
    myModule.foo() // foo() other data
    ```

- IIFE模式：匿名函数自调用(闭包)

  - 作用: 数据是私有的, 外部只能通过暴露的方法操作

  - 编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口

  - 问题: 如果当前这个模块依赖另一个模块怎么办?

  - ```js
    // index.html文件
    <script type="text/javascript" src="module.js"></script>
    <script type="text/javascript">
        myModule.foo()
        myModule.bar()
        console.log(myModule.data) //undefined 不能访问模块内部数据
        myModule.data = 'xxxx' //不能修改的模块内部的data
        myModule.foo() //没有改变
    </script>
    
    // module.js文件
    (function(window, $) {
      let data = 'www.baidu.com'
      //操作数据的函数
      function foo() {
        //用于暴露有函数
        console.log(`foo() ${data}`)
        $('body').css('background', 'red')
      }
      function bar() {
        //用于暴露有函数
        console.log(`bar() ${data}`)
        otherFun() //内部调用
      }
      function otherFun() {
        //内部私有的函数
        console.log('otherFun()')
      }
      //暴露行为
      window.myModule = { foo, bar }
    })(window, jQuery)
    ```

#### 3.优点

- 避免命名冲突(减少命名空间污染)
- 更好的分离, 按需加载
- 更高复用性
- 高可维护性

#### 4. 引入多个`<script>`后出现出现问题

- 请求过多：首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多
- 依赖模糊：我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。
- 难以维护

#### 5.函数式编程

>要点：
>
>- 一切都要函数化  =》输入输出数据流
>
>  ><img src="C:\Users\SFONE\AppData\Roaming\Typora\typora-user-images\image-20220726165157888.png" alt="image-20220726165157888" style="zoom:33%;" />
>  >
>  ><img src="C:\Users\SFONE\AppData\Roaming\Typora\typora-user-images\image-20220726165302526.png" alt="image-20220726165302526" style="zoom:33%;" />
>  >
>  >![image-20220726165509216](C:\Users\SFONE\AppData\Roaming\Typora\typora-user-images\image-20220726165509216.png)
>
>- 函数式编程的核心在于尽可能的纯粹
>
>- 函数式编程不使用while、for等方法，而是使用map, reduce，fileter等这样的高阶函数
>
>- 数据是不可变的
>
>  ><img src="C:\Users\SFONE\AppData\Roaming\Typora\typora-user-images\image-20220726170159613.png" alt="image-20220726170159613" style="zoom:33%;" />
>  >
>  ><img src="C:\Users\SFONE\AppData\Roaming\Typora\typora-user-images\image-20220726170313636.png" alt="image-20220726170313636" style="zoom: 25%;" />
>  >
>  >但是上述操作需要copy everything，每次改动都需要重新复制一份，当面对大对象时事情就变得不可控制了，时间、性能开销急剧增加
>  >
>  >解决方法是使用使用持久性数据结构 = 》共享结构
>  >
>  >持久性结构常见的库：mori.js -》闭包脚本   mutable.js，ramda

### 二、模块化规范

#### 1.CommonJS

##### (1) 概述

Node.js中常采用 CommonJS 模块规范，主要提供了module、exports、require、global几个环境变量来实现模块化。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。commonjs采用同步的方式加载模块，在服务端，这种方式不会出现问题，因为模块文件都存在本地，读取速度很快。但是如果在网页端使用commonjs方式进行模块化，由于网络的原因，就可能出现加载问题，所以nodejs是commonjs的最佳实践

在浏览器端，模块需要提前编译打包处理。

##### (2) 特点

- 所有代码都运行在模块作用域，不会污染全局作用域。
- 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
- 模块加载的顺序，按照其在代码中出现的顺序。

##### (3) 基本语法

- 暴露模块：`module.exports = value`或`exports.xxx = value`
- 引入模块：`require(xxx)`,如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径

```js
//add.js
function(a,b){
   console.log(a+b)
}
module.exports ={
    add,    //将方法暴露出去
}

//index.js
const addModule = require('./add') //引入add模块
addModule.add(1,2)  //调用模块中的方法
```

此处我们有个疑问：**CommonJS暴露的模块到底是什么?** CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。**加载某个模块，其实是加载该模块的module.exports暴露出的属性**。**require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错**。

##### (4) 模块的加载机制

CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，**一旦输出一个值，模块内部的变化就影响不到这个值**。主要是因为输出的值是个原始数据类型的值，会被缓存，引用类型则不一定。这点与ES6模块化有重大差异

#### 2.AMD

##### (1) 概述

**AMD规范则是非同步加载模块**，允许指定回调函数，模块的加载不影响它后面语句的运行。使用AMD规范时，通常需要使用`require.js`来进行异步加载模块，用`require.config()`指定引用路径等，用`define`定义模块，用`require`加载模块。与服务端环境相反，**在浏览器环境下，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范**。此外AMD规范比CommonJS规范在浏览器端实现要来着早。

##### (2) 语法

```js
// 引入require.js
<script src="js/require.js"></script> // 下载require.js后然后引入

// 首先用config()指定各模块路径和引用名，所有的模块都会以这个基础路径作为参考
require.config({
  baseUrl: "js/lib",
  paths: {
    "jquery": "jquery.min",  //实际路径为js/lib/jquery.min.js
    "underscore": "underscore.min",
  }
})

// 定义模块
define("模块名称-add", ["模块的依赖项,"], function(){
   函数体：模块的具体实现，模块中所有的代码全都放在该函数中
   
   return {XXX}  //想要暴露的模块
})

// 引用模块
require(["模块文件的路径(已经配置了基础路径，不带.js后缀的)-jquery"], function(){
    模块加载成功之后的回调函数
    模块的加载是异步的，在模块加载完成之后，才能使用模块的相关功能
})
```

##### (3) 使用

RequireJS是一个工具库，主要用于客户端的模块管理。它的模块管理遵守AMD规范，**RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载**。

```js
//alerter.js文件
// 定义有依赖的模块
define(['dataService'], function(dataService) {  //使用之前就要加载依赖模块
  let name = 'Tom'
  function showMsg() {
    alert(dataService.getMsg() + ', ' + name)
  }
  // 暴露模块
  return { showMsg }
})

//main.js中引入alerter.js中的模块，并使用其暴露的showMag方法
 require(['alerter'], function(alerter) {
    alerter.showMsg()
  })


<!-- 引入require.js并指定js主文件的入口 -->
<script data-main="js/main" src="js/libs/require.js"></script>
```

通过两者的比较，可以得出**AMD模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系**。AMD模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块。

#### 3.CMD

- CMD是另一种js模块化方案，它与AMD很类似，不同点在于：**AMD 推崇依赖前置**、提前执行**，**CMD推崇依赖就近、延迟执行**。CMD主要使用的时seajs来进行的模块化管理。.
- CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。

```js
//定义math.js
define(function(require,exports,moduls){  //直接是回调函数
    var $ = require('juqery.js')  //使用时才加载依赖模块
    var add= function(a,b){
        return a+b
    }
    export.add =add
});
//加载模块
seajs.use(['math.js'],function(math){
    var sum = math.add(1+2)
})
```

#### 4.ES6 Module

##### (1) 概述

- 基于ES6 在语言标准的层面上，ES6 Module实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：`export`和`import`。`export`命令用于规定模块的对外接口，`import`命令用于输入其他模块提供的功能。

- 主要在VUE中使用。ES6 模块的设计思想是**尽量的静态化，**使得**编译时**就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在**运行时**确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。
- ES6模块规范是前端最流行的模块规范，定义、暴露和引入模块比AMD和CommonJS都简单得多。只是额外工作多了些，不仅**需要使用babel等库将ES6转换成ES5**,以便浏览器识别，还要使用browserify等库编译打包代码。

##### (2) 语法

export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。

```js
/** 定义模块 math.js **/
var basicNum = 0;
var add = function (a, b) {
    return a + b;
};
export { basicNum, add };  //暴露方法

/** 引用模块 **/
import { basicNum, add } from './math';
function test(ele) {
    ele.textContent = add(99 + basicNum);
}

export default function () {  //默认暴露
  console.log('foo');
}
//模块默认输出, 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。
```

##### (3) 对比

它们有两个重大差异：

- **CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用**。**ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块**。所以ES6模块导出的内容可以影响到输出的值

- **CommonJS 模块是运行时加载，ES6 模块是编译时输出接口**。

  第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

#### 5.总结

- CommonJS规范主要**用于服务端编程，加载模块是同步的**，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。
- AMD规范在**浏览器环境中异步加载模块**，而且可以**并行加载**多个模块。不过，**AMD规范开发成本高**，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。
- CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重
- **ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案**。

### 三.前后端分离

#### 1.定义

大家一致认同的前后端分离的例子就是**SPA**(Single-page application)，所有用到的展现数据都是**后端通过异步接口**(AJAX/JSONP)的方式提供的，前端只管展现。 
从某种意义上来说，SPA确实做到了前后端分离，但这种方式存在两个问题：

- WEB服务中，SPA类占的比例很少。很多场景下还有同步/同步+异步混合的模式，SPA不能作为一种通用的解决方案。
- 现阶段的SPA开发模式，接口通常是按照展现逻辑来提供的，有时候为了提高效率，后端会帮我们处理一些展现逻辑，这就意味着后端还是涉足了View层的工作，不是真正的前后端分离。

SPA式的前后端分离，是从物理层做区分（认为只要是客户端的就是前端，服务器端的就是后端), 这种分法已经无法满足我们前后端分离的需求，我们认为从职责上划分才能满足目前我们的使用场景：

- 前端：负责View和Controller层。
- 后端：只负责Model层，业务处理/数据等。

从初始的JSP开始 -》模块化，工程化，项目管理的问题 =》解耦=》具体的MVP，MVC,MVVM

#### 2.对前后端分离的理解

**历史渊源**：在互联网萌芽时期，后端工程师往往是项目和公司的核心团队。那时候前端开发主要使用JSP，前后端耦合。但是随着互联网应用朝着web端发展，前端页面的数量急剧上升，JSP“套模板”的形式已经满足不了当前的需求。

**存在问题**：Html，css，js，jquery等在做复杂页面时会变得非常的繁杂。其本质原因在于前端没有工程化、模块化和可复用化的思维的来做。那时候前端没有像Spring这样的工程化开发框架。此时开发必然出现一些不协调、效率低等问题。从公司项目角度来看，这种开发模式非常影响效率。

**解决方案**：解耦=》高内聚，低耦合。具体的实现方式包括目前的vue，react等开发框架。大家开始遵循一套体系来进行约束性的开发。所以前后端分离本身它不是一个技术问题，而是一种工程化上的考量、项目管理的问题。目前，前端也可以借助node，开发各种各样的工具，包括包管理器、预编译工具等。

在前端设计方面，模型接口的约定极为重要，包括接口的请求方式、数据类型等

## 四. 模块化工具

### 4.1 Git

1.基本命令：

![aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODA4NzQzNS1iZjJhOTk2ZWY1MGEyMWIwLmpwZw.jfif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b20a02e7f114884b8015c082d4a9c7b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

- 基础配置
- 本地仓库操作
- 远程仓库操作
- 分支操作
- 标签管理

### 4.2 Webpack

#### 0.比较

##### 1. webpack、rollup、parcel优劣？  

- webpack**适⽤于⼤型复杂的前端站点构建**: webpack有强⼤的loader和plugin插件⽣态,打包后的⽂件实际上就是⼀个**⽴即执⾏函数**，这个⽴即执⾏函数接收⼀个参数，**这个参数是模块对象，键为各个模块的路径，值为模块内容**。⽴即执⾏函数内部则处理模块之间的引⽤，执⾏模块等,这种情况**更适合⽂件依赖复杂**的应⽤开发。 
- rollup适**⽤于基础库**的打包，如vue、d3等: Rollup 就是将各个模块打包进⼀个⽂件中，并且通过 Tree-shaking 来删除⽆⽤的代码,可以最⼤程度上降低代码体积,但是rollup没**有webpack如此多的的如代码分割、按需加载等⾼级功能**，其更聚焦于库的打包，因此更适合库的开发。
- parcel适⽤于简单的实验性项⽬: 他可以满⾜低⻔槛的快速看到效果,但是⽣态差、报错信息不够全⾯都是他的硬伤，除了⼀些玩具项⽬或者实验项⽬不建议使⽤。

##### 2. webpack与grunt、gulp的不同？ 

- Grunt、Gulp是基于任务运⾏的⼯具： 它们会⾃动执⾏指定的任务，就像流⽔线，把资源放上去然后通过不同插件进⾏加⼯，它们包含活跃的社区，丰富的插件，能⽅便的打造各种⼯作流。 
- Webpack是基于模块化打包的⼯具: ⾃动化处理模块，webpack把⼀切当成模块，当 webpack 处理应⽤程序时，它会递归地构建⼀个依赖关系图 (dependency graph)，其中包含应⽤程序需要的每个模块，然后将所有这些模块打包成⼀个或多个 bundle。 
- 因此这是完全不同的两类⼯具,⽽现在主流的⽅式是⽤npm script代替Grunt、Gulp，npm script同样可以打造任务流。

 

#### 1.定义

- Webpack是一个模块打包工具，本身可以实现模块化代码打包的问题。通过webpack可以将零散的JS代码打包到一个JS文件中
- 对于环境兼容问题的代码：webpack可以在打包过程中通过loader机制对其实现编译转换，然后再进行打包
- 对于不同类型的前端模块，webpack支持在js中以模块化的方式载入任意类型的资源文件（例如在js中加载css文件，被加载的css文件会通过**style标签**的形式工作）
- 具备代码拆分的能力：能过将应用中所有的模块**按需分块打包**，不用担心全部代码打包到一起，产生**单个文件过大**，导致**加载慢**的问题

上述说明，webpack适合大型现代化的web应用

#### 2.模块

- Entry ：入口起点(entry point)指示 webpack 应该使用哪个模块,来作为构建其内部依赖图的开始。进入入口起点后,webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。每个依赖项随即被处理,最后输出到称之为 bundles 的文件中。
- Output： 告诉 webpack 在哪里输出它所创建的 bundles,以及如何命名这些文件,默认值为 ./dist。基本上,整个应用程序结构,都会被编译到你指定的输出路径的文件夹中。
- module：在 Webpack 里一切皆模块,一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。
- chunk：代码块,一个 Chunk 由多个模块组合而成,用于代码合并与分割。

- loader: 用于对模块的源代码进行转换。loader让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。甚至可以支持直接`import`css文件

  本质上,webpack loader 将所有类型的文件,转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。

- >常见的Loader：
  >
  >- file-loader：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 URL 去引⽤输出的⽂件 
  >- url-loader：和 file-loader 类似，但是能在⽂件很⼩的情况下以 base64 的⽅式把⽂件内容注⼊到代码中去 
  >- source-map-loader：加载额外的 Source Map ⽂件，以⽅便断点调试 
  >- image-loader：加载并且压缩图⽚⽂件 
  >- babel-loader：把 ES6 转换成 ES5 
  >- css-loader：加载 CSS，⽀持模块化、压缩、⽂件导⼊等特性 
  >- style-loader：把 CSS 代码注⼊到 JavaScript 中，通过 DOM 操作去加载 CSS。 
  >- eslint-loader：通过 ESLint 检查 JavaScript 代码 
  >
  >**注意**：在Webpack中，loader的执行顺序是从右向左执行的。因为webpack选择了compose这样的函数式编程方式，这种方式的表达式执行是从右向左的。

- Plugin: loader被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运⾏的⽣命周期中**会⼴播出许多事件**，Plugin 可以监听感兴趣的事件，执行特定的逻辑，在合适的时机通过 Webpack 提供的 API 改变输出结果。

  >- define-plugin：定义环境变量 
  >- html-webpack-plugin：简化html⽂件创建 
  >- uglifyjs-webpack-plugin：通过 UglifyES 压缩 ES6 代码 
  >- webpack-parallel-uglify-plugin: 多核压缩，提⾼压缩速度 
  >- webpack-bundle-analyzer: 可视化webpack输出⽂件的体积 
  >
  >- mini-css-extract-plugin: CSS提取到单独的⽂件中，⽀持按需加载 

- 编写loader或plugin的思路

  >Loader像⼀个"翻译官"把读到的源⽂件内容转义成新的⽂件内容，并且每个Loader通过链式操作，将源⽂件⼀步步翻译成想要的样⼦。 
  >
  >编写Loader时要遵循单⼀原则，每个Loader只做⼀种"转义"⼯作。 每个Loader的拿到的是源⽂件内容（source），可以通过返回值的⽅式将处理后的内容输出，也可以调⽤ this.callback() ⽅法，将内容返回给webpack。 还可以通过this.async() ⽣成⼀个 callback 函数，再⽤这个callback将处理后的内容输出出去。 此外 webpack 还为开发者准备了开发loader的⼯具函数集——loader-utils 。 
  >
  >相对于Loader⽽⾔，Plugin的编写就灵活了许多。 webpack在运⾏的⽣命周期中会⼴播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果

- bundle，chunk，module

  >- bundle：是由webpack打包出来的⽂件； 
  >- chunk：代码块，⼀个chunk由多个模块组合⽽成，⽤于代码的合并和分割；
  >- module：是开发中的单个模块，在webpack的世界，⼀切皆模块，⼀个模块对应⼀个⽂件，webpack会从配置的 entry中递归开始找出所有依赖的模块。

#### 3.使用流程

1. 全局安装 `npm install webpack webpack-cli`

2. 在项目中初始化webpack项目：`npm init -y`

3. 在项目中安装webpack并选择开发模式`cnpm install webpack webpack-cli --save-dev`

   - 以**开发者**模式打包文件，选择输出（-o）到指定目录下:`webpack ./src/index.js -o ./dist/bundle.js --mode=development`(打包后的代码有注释，可读性高)

     以**生产模**式打包文件，使用`webpack ./src/index.js -o ./dist/bundle_production.js --mode=production`（打包后的代码无注释，代码已压缩混淆，可读性差）

   - 配置webpack.config.js进行打包。在项目文件的webpack.config.js文件中，设置如下内容：

     ```js
     let path = require('path')   //node中的自带模块，获取当前路径
     
     module.export ={
         //入口文件：
         entry:'./src/index.js',
         output:{
             //输出文件名
             filename:"bundle.js",
             //输出路径
             //绝对路径
             path:path.resolve(__dirname,'dist')  //获取当前绝对目录，拼接dist文件夹，并将bundle.js文件输入到该目录下
         },
         //开发模式
         mode:'development'，
         module:{
             //对某种格式的文件转换处理
             rules: [
                {
                     test: /\.css$/,
                     use: ['style-loader','css-loader']
                 },{
                     test:/\.(jpg|png|gif)$/,   //匹配图片文件
                     loader:'url-loader',
                     //图片设置
                     options:{
                         limit:8*1024,   //图片小于8kb，base64处理，减少请求数量，会使得体积更大
                         esModule:false,  //关闭url-loader的es6模块化解析
                         name:'[hash:10].[ext]'  //取图片hash值的前10位，并获得图片的扩展名
                     }
                 },{
                     test:/\.html$/,
                     loader:'html-loader'
                 }
             ],
          
         },
         //配置插件
         plugins:[
             new HtmlWebpackPlugin({
                 template:'src/index.html'   //可以直接在浏览器中直接打开index.html文件，不用在html文件中引入打包后的bundle/main.js
             })
         ],
         devServe:{   //代码热更新，实时加载刷新页面内容
             //项目构建路径
             contentBase:path.resolve(__dirname,'dist'),
             //启动编码压缩
             compress:true,
            //设置项目端口号
             port:3000,
             //自动打开浏览器    
             open:true
         }    
     }
     
     //依赖的npm包：
     "devDependencies": {
         "css-loader": "^6.7.1",
         "file-loader": "^6.2.0",
         "html-loader": "^4.1.0",
         "html-webpack-plugin": "^5.5.0",
         "style-loader": "^3.3.1",
         "url-loader": "^4.1.1"
       },
     ```

**总结：**

Webpack 的运⾏流程是⼀个串⾏的过程，从启动到结束会依次执⾏以下流程： 

1. 初始化参数：从配置⽂件和 Shell 语句中读取与合并参数，得出最终的参数； 
2. 开始编译：⽤上⼀步得到的参数初始化 Compiler 对象，加载所有配置的插件，执⾏对象的 run ⽅法开始执⾏编译； 
3. 确定⼊⼝：根据配置中的 entry 找出所有的⼊⼝⽂件； 
4. 编译模块：从⼊⼝⽂件出发，调⽤所有配置的 Loader 对模块进⾏翻译，再找出该模块依赖的模块，再递归本步骤直到所有⼊⼝依赖的⽂件都经过了本步骤的处理； 
5. 完成模块编译：在经过第4步使⽤ Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系； 
6. 输出资源：根据⼊⼝和模块之间的依赖关系，组装成⼀个个包含多个模块的 Chunk，再把每个 Chunk 转换成⼀个单独的⽂件加⼊到输出列表，这步是可以修改输出内容的最后机会； 
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和⽂件名，把⽂件内容写⼊到⽂件系统。

#### 4.代码热更新

webpack的热更新⼜称热替换（Hot Module Replacement），缩写为HMR。 这个机制可以做到不⽤刷新浏览器⽽将新变更的模块替换掉旧的模块。 

<img src="C:\Users\SFONE\AppData\Roaming\Typora\typora-user-images\image-20220727213421115.png" alt="image-20220727213421115" style="zoom:67%;" />

#### 5.webpack优化

##### 1.webpack构建时间优化：

- **thread-loader:** 多进程打包，可以大大提高构建的速度，使用方法是将`thread-loader`放在比较费时间的loader之前

  ```js
  npm i thread-loader -D
  复制代码
  // webpack.base.js
  {
          test: /\.js$/,
          use: [
            'cache-loader'	
            'thread-loader',
            'babel-loader'
          ],
        }
  }
  ```

- **cache-control**: 缓存资源，提高二次构建的速度，使用方法是将cache-loader放在比较费时间的loader之前,如上述代码

- **开启热更新**：比如你修改了项目中某一个文件，会导致整个项目刷新，这非常耗时间。如果只刷新修改的这个模块，其他保持原状，那将大大提高修改代码的重新构建时间

  ```js
  // webpack.dev.js
  //引入webpack
  const webpack = require('webpack');
  //使用webpack提供的热更新插件
  plugins: [
    new webpack.HotModuleReplacementPlugin()  
  ],
      //最后需要在我们的devserver中配置
  devServer: {
    hot: true
  },
  ```

- exclude & include

  - `exclude`：不需要处理的文件
  - `include`：需要处理的文件

  合理设置这两个属性，可以大大提高构建速度

  ```js
  // webpack.base.js
  {
          test: /\.js$/,
          //使用include来指定编译文件夹
          include: path.resolve(__dirname, '../src'),
          //使用exclude排除指定文件夹
          exclude: /node_modules/,
          use: [
            'babel-loader'
          ]
  },
  ```

- 构建区分环境

  区分环境去构建是非常重要的，我们要明确知道，开发环境时我们需要哪些配置，不需要哪些配置；而最终打包生产环境时又需要哪些配置，不需要哪些配置：

  - `开发环境`：**去除**代码压缩、gzip、体积分析等优化的配置，大大提高构建速度
  - `生产环境`：**需要**代码压缩、gzip、体积分析等优化的配置，大大降低最终项目打包体积

- 提升webpack版本

- CDN优化…

##### 2.webpack打包体积优化

- css代码压缩：CSS代码压缩使用`css-minimizer-webpack-plugin`，效果包括压缩、去重

  ```js
  npm i css-minimizer-webpack-plugin -D
  
  // webpack.prod.js
  const CssMinimizerPlugin = require('css-minimizer-webpack-plugin')
    optimization: {
      minimizer: [
        new CssMinimizerPlugin(), // 去重压缩css
      ],
    }
  ```

- js代码压缩：JS代码压缩使用`terser-webpack-plugin`，实现打包后JS代码的压缩

  ```js
  npm i terser-webpack-plugin -D
  // webpack.prod.js
  
  const TerserPlugin = require('terser-webpack-plugin')
  
    optimization: {
      minimizer: [
        new CssMinimizerPlugin(), // 去重压缩css
        new TerserPlugin({ // 压缩JS代码
          terserOptions: {
            compress: {
              drop_console: true, // 去除console
            },
          },
        }), // 压缩JavaScript
      ],
    }
  ```

- 使用`webpack-bundle-analyzer`可以审查打包后的体积分布，进而进行相应的体积优化

  ```js
  npm i webpack-bundle-analyzer -D
  // webpack.prod.js
  
  const {
    BundleAnalyzerPlugin
  } = require('webpack-bundle-analyzer')
  
    plugins: [
      new BundleAnalyzerPlugin(),
  ]
  ```

  <img src="C:\Users\SFONE\AppData\Roaming\Typora\typora-user-images\image-20220727221330929.png" alt="image-20220727221330929" style="zoom:67%;" />

- source-map:方便你报错的时候能定位到错误代码的位置。它的体积不容小觑，所以对于不同环境设置不同的类型是很有必要的

- tree-shaking…

##### 3.用户体验优化

- **懒加载**：如果不进行`模块懒加载`的话，最后整个项目代码都会被打包到一个js文件里，单个js文件体积非常大，那么当用户网页请求的时候，首屏加载时间会比较长，使用`模块懒加载`之后，大js文件会分成多个小js文件，网页加载时会按需加载，大大提升首屏加载速度

- **Gzip**：开启Gzip后，大大提高用户的页面加载速度，因为gzip的体积比原文件小很多，当然需要后端的配合，使用`compression-webpack-plugin`

  ```js
  npm i compression-webpack-plugin -D
  
  // webpack.prod.js
  const CompressionPlugin = require('compression-webpack-plugin')
    plugins: [
      // 之前的代码...
      
      // gzip
      new CompressionPlugin({
        algorithm: 'gzip',
        threshold: 10240,
        minRatio: 0.8
      })
    ]
  ```

- 小图片转base64

#### 6.配置SPA与MPA

单⻚应⽤可以理解为webpack的标准模式，直接在 entry 中指定单⻚应⽤的⼊⼝即可，这⾥不再赘述多⻚应⽤的话，可以使⽤webpack的 AutoWebPlugin 来完成简单⾃动化的构建，但是前提是项⽬的⽬录结构必须遵守他预设的规范。 多⻚应⽤中要注意的是： 

- 每个⻚⾯都有公共的代码，可以将这些代码抽离出来，避免重复的加载。⽐如，每个⻚⾯都引⽤了同⼀套css样式表
- 随着业务的不断扩展，⻚⾯可能会不断的追加，所以⼀定要让⼊⼝的配置⾜够灵活，避免每次添加新⻚⾯还需要修改构建配置 

### 7.webpack兼容ES5与ES6

使用Babel将ES6转为ES5语法

**1.安装babel-loader** : 架起连接webpack和babel的桥梁

 `npm install babel-loader @babel/core`

**2.安装env preset：**将ES6转换为ES5

`npm install @babel/preset-env --save-dev`

**3.配置webpack中的babel**：

```js
module: {
  rules: [
      // 对js文件进行babel-loader处理（使支持ES6语法）
      {
        test: /.js$/,
        exclude: /node_modules/,
        loader: "babel-loader", // 架桥梁
        options: {
          presets: [
            [
              "@babel/preset-env",// 将ES6语法转成ES5
              {
                // 低版本浏览器中只补充项目中使用到的ES6语法
                useBuiltIns: "usage" 
              }
            ]
          ]
        }
      }
  ]
}
```

**4.使用@babel/polyfill**：让低版本支持所有的ES6语法

虽然做了语法翻译，但只是一部分。在低版本浏览器还是没有比如Promise、数组的map等。所以不仅要使用`@babel/preset-env`进行ES6转ES5，还要**借助 `@babel/polyfill`把缺失的变量或者函数补充到低版本的浏览器里**。

下载： `npm install --save @babel/polyfill`

引入：`import "@babel/polyfill";`



### 3. 规范化

- ESlint/TSlint
- Stylelint
- Prettier

### 3. 自动化

- 自动化构建

- - Gulp
  - NPM Script

- 自动化部署（CI/CD）

- - 持续集成
  - 持续部署
  - 自动化工作流
  - 项目自动部署

- - 