## 五、前端性能优化

在开始之前，我们需要明白一个原则：**性能优化的最终目的是提升用户体验**。
 简而言之就是让用户感觉这个网站很「快」，这里的「快」有两种，一种是「真的快」一种是「觉得快」

- 「真的快」：可以客观衡量的指标，像网页访问时间、交互响应时间、跳转页面时间
- 「觉得快」：用户主观感知的性能，通过视觉引导等手段转移用户对等待时间的关注

### 0.首屏加载优化

我们知道是app.js文件太大，加载时间太长导致了首屏加载速度过慢，我们就需要对症下药减小app.js的大小，提高网站访问速度。

1. 压缩：对代码压缩，减少体积量
2. 路由懒加载：按需加载路由，动态引入
3. 图片懒加载
4. 雪碧图
5. 虚拟列表
6. 使用CDN，从最近的服务器中请求资源
7. SSR服务端渲染

### 1. 骨架屏

#### 1.1 定义

骨架屏可以理解为在页面数据尚未返回或页面未完成完全渲染前，先给用户呈现一个由灰白块组成的当前页面大致结构，让用户产生页面正在逐渐渲染的感受，从而使加载过程从视觉上变得流畅。直到请求数据返回后再渲染页面，补充进需要显示的数据内容。常用于文章列表、动态列表页等相对比较规则的列表页面。

#### 1.2 优点

1.用户避免看到长时间的白页
2.可以获知页面的大体结构，减小用户认为页面出错而离开的机率
3.与菊花图相比视觉更加流畅

#### 1.3  实现方法

1. UI 骨架屏图

   即通过 UI 提供符合页面首页样式的图来充当骨架屏，将骨架屏 base64 图片插入 root 根节点，在 webpack 打包时嵌入项目中。

   这是一种简单粗暴的方法，实现起来比较容易。但缺点也很明显，就是需要 UI 设计师支持和开发介入，不能自动生成。

2. 手写骨架屏

   即通过手写 HTML、CSS 的方式为目标页定制骨架屏。这种方式可以做到对页面真实样式的复刻。不过一旦由于各种原因导致页面样式发生改变，就需要再改一遍骨架屏的样式和布局，极大增加了维护的成本。

3. 自动生成静态骨架屏 

   目前比较受关注的是饿了么开源的插件 page-skeleton-webpack-plugin，它生成骨架屏的方案可以根据项目中不同的路由页面生成相应的骨架屏页面，并将骨架屏页面通过 webpack 打包到对应的静态路由页面中。

### 2. 懒加载

#### 1.1 定义

懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。

如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。

#### 1.2 特点

- 减少无用资源的加载：使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。
- 提升用户体验: 如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。
- 防止并发加载的资源过多会阻塞js的加载，影响网站的正常使用

#### 1.3 实现代码

首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则设置在`data-xxx`属性中， 当页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区域,如果图片在可视区内将图片的 src 属性设置为`data-xxx `的值，这样就可以实现延迟加载。

注意：`data-xxx `中的xxx可以自定义，这里我们使用data-src来定义。

懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。

使用原生JavaScript实现懒加载：
知识点：
（1）`window.innerHeight` 是浏览器可视区的高度
（2）`document.body.scrollTop` ||` document.documentElement.scrollTop` 是浏览器滚动的过的距离
（3）`imgs.offsetTop` 是元素顶部距离文档顶部的高度（包括滚动条的距离）
（4）图片加载条件：`img.offsetTop < window.innerHeight + document.body.scrollTop`;

<img src="C:\Users\SFONE\AppData\Roaming\Typora\typora-user-images\image-20220706144527874.png" alt="image-20220706144527874" style="zoom: 67%;" />



```js
<div class="container">
     <img src="loading.gif"  data-src="pic.png">
     <img src="loading.gif"  data-src="pic.png">
     <img src="loading.gif"  data-src="pic.png">
     <img src="loading.gif"  data-src="pic.png">
     <img src="loading.gif"  data-src="pic.png">
     <img src="loading.gif"  data-src="pic.png">
</div>


<script>
var imgs = document.querySelectorAll('img');
function lozyLoad(){
		var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
		var winHeight= window.innerHeight;
		for(var i=0;i < imgs.length;i++){
			if(imgs[i].offsetTop < scrollTop + winHeight ){
				imgs[i].src = imgs[i].getAttribute('data-src');
			}
		}
	}
  window.onscroll = lozyLoad();
</script>
```

#### 1.5 预加载与懒加载

预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。

这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。

```js
var promiseAll = imgData.map(function (item, index) {
    return new Promise(function (resolve, reject) {
      var img = new Image();
      img.onload = function () {
        img.onload = null;
        resolve(img);
      };
      img.error = function () {
        reject('图片加载失败');
      };
      img.src = item;
    });
  });
  Promise.all(promiseAll).then(
    function () {
      // 图片全部加载完成，进行下一步
      // todo
    },
    function (err) {
      console.log(err);
    }
  );
```

### 3.首屏与白屏

##### **白屏**

白屏时间(First Paint)：是指浏览器从响应用户输入网址地址，到**浏览器开始显示内容**的时间。

- 白屏时间 = 页面开始展示的时间点 - 开始请求的时间点

白屏时间是从用户开始请求页面时开始计算到开始显示内容结束，中间过程包括DNS查询、建立TCP链接、发送首个HTTP请求、返回HTML文档、HTML文档head解析完毕。

因此影响白屏时间的因素：网络、服务端性能、前端页面结构设计。

##### 首屏：

首屏时间 (First Contentful Paint)：是指浏览器从响应用户输入网络地址，到首屏**内容渲染完成**的时间。（首屏时间一定比白屏时间长）

- 首屏时间 = 首屏内容渲染结束时间点 - 开始请求的时间点

**选择**

对于交互性比较少的简单网页，由于加载比较快，所以二者区别不大，因此，可以根据喜好任选一种计算方式。

对于大型的复杂页面，你会发现由于需要处理更多复杂的元素，白屏时间和首屏时间相隔比较远，这时候，计算首屏时间会更有用。

### 4 .前端上传大文件的解决方案

在某些业务中，大文件上传是一个比较重要的交互场景，如上传入库比较大的Excel表格数据、上传影音文件等。如果文件体积比较大，或者网络条件不好时，上传的时间会比较长（要传输更多的报文，丢包重传的概率也更大），用户不能刷新页面，只能耐心等待请求完成。

- 先传统的做法是服务器压缩（想要了解服务器压缩的请谷歌或者百度FFmpeg命令），参考服务器压缩，服务器压缩是多种的，可以压缩视频的帧数、压缩视频的画质（图像的画质）、改变文件编码。

### 5. 图片优化

#### 1.如何对项目中的图片进行优化？

1. 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。
2. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
3. 小图使用 base64 格式或者font-icon
4. 将多个图标文件整合到一张图片中（雪碧图）
5. 选择正确的图片格式：

- 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
- 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
- 照片使用 JPEG

#### 2.常见图片及使用场景

1. BMP，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。
2. GIF是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。
3. JPEG是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。
4. PNG-8是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8
5. PNG-24是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。
6. SVG是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制Logo、Icon等。
7. WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。

- 在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；
- 在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；
- WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。

### 6. 节流防抖

#### 6.1 定义

节流防抖就好比乘电梯，比如delay是10秒，name防抖就是电梯每进来一个人就要等10秒再运行，而节流就是电梯保证每10秒可以运行一次

- 函数防抖是指在**事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。**这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。个人理解 函数防抖就是法师发技能的时候要读条，技能读条没完再按技能就会重新读条。
- 函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，**如果在同一个单位时间内某事件被触发多次，只有一次能生效**。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。个人理解 函数节流就是fps游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。

#### 6.2 使用场景

防抖函数的应用场景：

- 按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次 
- 服务端验证场景：search搜索联系，用户在不断输入值时，用防抖来节约请求资源

节流函数的适⽤场景： 

- 拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动 
- 缩放场景：监控浏览器resize 
- 动画场景：避免短时间内多次触发动画引起性能问题 

#### 6.3 代码实现，详见手写代码篇

利用输入框实现防抖：

```js
//-----------------------------------------防抖-------------------------------------------------
function debounce(fn, wait) {
  var timer = null;

  return function() {
    var context = this,
      args = [...arguments];

    // 如果此时存在定时器的话，则取消之前的定时器重新记时
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }

    // 设置定时器，使事件间隔指定事件后执行
    timer = setTimeout(() => {
      fn.apply(context, args);
    }, wait);
  }; 
}

//-----------------------------------------节流-------------------------------------------------
// 时间戳版
function throttle(fn, delay) {
  var preTime = Date.now();

  return function() {
    var context = this,
      args = [...arguments],
      nowTime = Date.now();

    // 如果两次时间间隔超过了指定时间，则执行函数。
    if (nowTime - preTime >= delay) {
      preTime = Date.now();
      return fn.apply(context, args);
    }
  };
}

// 定时器版
function throttle (fun, wait){
  let timeout = null
  return function(){
    let context = this
    let args = [...arguments]
    if(!timeout){
      timeout = setTimeout(() => {
        fun.apply(context, args)
        timeout = null 
      }, wait)
    }
  }
}
```



### 7. 回流重绘

渲染流水线

![image-20220706150511769](C:\Users\SFONE\AppData\Roaming\Typora\typora-user-images\image-20220706150511769.png)

#### 7.1 回流（重排）

当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染**部分或者全部文档**的过程就称为回流。

下面这些操作会导致回流：

- 页面的首次渲染
- 浏览器的窗口大小发生变化
- 元素的内容发生变化
- 元素的尺寸或者位置发生变化
- 元素的字体大小发生变化
- 查询某些属性或者调用某些方法
- 添加或者删除可见的DOM元素

在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：

- 全局范围：从根节点开始，对整个渲染树进行重新布局
- 局部范围：对渲染树的某部分或者一个渲染对象进行重新布局

#### 7.2 重绘

当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是重绘。

下面这些操作会导致重绘：

- color、background 相关属性：background-color、background-image 等

- outline 相关属性：outline-color、outline-width 、text-decoration

- border-radius、visibility、box-shadow

**注意： 当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。**

#### 7.3 如何避免回流与重绘

>浏览器使用流式布局模型 (Flow Based Layout)。
>
>浏览器会把`HTML`解析成`DOM`，把`CSS`解析成`CSSOM`，`DOM`和`CSSOM`合并就产生了`Render Tree`。
>
>有了`RenderTree`，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。减少回流、重绘其实就是需要减少对render tree的操作，并减少对一些style信息的请求，尽量利用好浏览器的优化策略 
>
>由于浏览器使用流式布局，对`Render Tree`的计算通常只需要遍历一次就可以完成，但`table`及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用`table`布局的原因之一。

**CSS:**

- 避免使用`table`布局, 一个小的改动可能会使整个`table`进行重新布局
- 尽可能在`DOM`树的最末端改变`class`,可以限制回流的范围，使其影响尽可能少的节点。
- 避免设置多层内联样式, 因为每一个样式都可能会造成回流，样式合并在一个外部类，这样当该元素的class属性被操作时，只会产生一个reflow。 
- 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上, 使元素脱离文档流，这样他们发生变化就不会影响其他元素（例如动画效果应用到position属性为absolute或fixed的元素上。 ）
- 避免使用`CSS`表达式（例如：`calc()`）。

**JavaScript:**

- 避免频繁操作样式，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性。
- 避免频繁操作`DOM`，创建一个`documentFragment`，在它上面应用所有`DOM操作`，最后再把它添加到文档中。
- 也可以先为元素设置`display: none`，操作结束后再把它显示出来。因为在`display`属性为`none`的元素上进行的`DOM`操作不会引发回流和重绘。
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。

- 操作DOM时，尽量在低层级的DOM节点进行操作，将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列。**浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。**多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。

#### 7.4 如何优化动画

对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作DOM，就就会导致页面的性能问题，我们可以将动画的`position`属性设置为`absolute`或者`fixed`，将动画脱离文档流，这样他的回流就不会影响到页面了。

### 8. 虚拟列表

#### 8.1 长列表

前端的业务开发中会遇到一些数据量大且无法使用分页方式来加载的列表，一般把这种列表叫做长列表。纯渲染的整体体验非常不好，主要有以下问题：

- 页面等待时间极长，用户体验差
- CPU计算能力不够，滑动会卡顿
- GPU渲染能力不够，页面会跳屏
- RAM内存容量不够，浏览器崩溃

对于长列表渲染，传统的方法是使用懒加载的方式，下拉到底部获取新的内容加载进来，其实就相当于是在垂直方向上的分页叠加功能，**`但随着加载数据越来越多，浏览器的回流和重绘的开销将会越来越大`**，整个滑动也会造成卡顿，这个时候我们就可以考虑使用虚拟列表来解决问题

#### 8.2 虚拟列表

虚拟列表的实现，实际上就是在首屏加载的时候，只加载`可视区域`内需要的列表项，当滚动发生时，动态通过计算获得`可视区域`内的列表项，并将`非可视区域`内存在的列表项删除。具体步骤为：（微博使用了虚拟列表）

- 计算当前`可视区域`起始数据索引(`startIndex`)
- 计算当前`可视区域`结束数据索引(`endIndex`)
- 计算当前`可视区域的`数据，并渲染到页面中
- 计算`startIndex`对应的数据在整个列表中的偏移位置`startOffset`并设置到列表上

>- 假定`可视区域`高度固定，称之为`screenHeight`
>- 假定`列表每项`高度固定，称之为`itemSize`
>- 假定`列表数据`称之为`listData`
>- 假定`当前滚动位置`称之为`scrollTop`
>
>列表总高度`listHeight` = listData.length * itemSize
>
>可显示的列表项数`visibleCount` = Math.ceil(screenHeight / itemSize)
>
>数据的起始索引`startIndex` = Math.floor(scrollTop / itemSize)
>
>数据的结束索引`endIndex` = startIndex + visibleCount
>
>列表显示数据为`visibleData` = listData.slice(startIndex,endIndex)
>
>



<img src="C:\Users\SFONE\AppData\Roaming\Typora\typora-user-images\image-20220707160431953.png" alt="image-20220707160431953" style="zoom:50%;" />

```js
//-------------------------------------HTML结构------------------------------------------------
//infinite-list-container 为可视区域的容器
//infinite-list-phantom 为容器内的占位，高度为总列表高度，用于形成滚动条
//infinite-list 为列表项的渲染区域
<template>
  <div ref="list" class="infinite-list-container" @scroll="scrollEvent($event)">
    <div class="infinite-list-phantom" :style="{ height: listHeight + 'px' }"></div>
    <div class="infinite-list" :style="{ transform: getTransform }">
      <div ref="items"
        class="infinite-list-item"
        v-for="item in visibleData"
        :key="item.id"
        :style="{ height: itemSize + 'px',lineHeight: itemSize + 'px' }"
      >{{ item.value }}</div>
    </div>
  </div>
</template>
export default {
  name:'VirtualList',
  props: {
    //所有列表数据
    listData:{
      type:Array,
      default:()=>[]
    },
    //每项高度
    itemSize: {
      type: Number,
      default:200
    }
  },
  computed:{
    //列表总高度
    listHeight(){
      return this.listData.length * this.itemSize;
    },
    //可显示的列表项数
    visibleCount(){
      return Math.ceil(this.screenHeight / this.itemSize)
    },
    //偏移量对应的style
    getTransform(){
      return `translate3d(0,${this.startOffset}px,0)`;
    },
    //获取真实显示列表数据
    visibleData(){
      return this.listData.slice(this.start, Math.min(this.end,this.listData.length));
    }
  },
  mounted() {
    this.screenHeight = this.$el.clientHeight;
    this.start = 0;
    this.end = this.start + this.visibleCount;
  },
  data() {
    return {
      //可视区域高度
      screenHeight:0,
      //偏移量
      startOffset:0,
      //起始索引
      start:0,
      //结束索引
      end:null,
    };
  },
  methods: {
    scrollEvent() {
      //当前滚动位置
      let scrollTop = this.$refs.list.scrollTop;
      //此时的开始索引
      this.start = Math.floor(scrollTop / this.itemSize);
      //此时的结束索引
      this.end = this.start + this.visibleCount;
      //此时的偏移量
      this.startOffset = scrollTop - (scrollTop % this.itemSize);
    }
  }
};

```

### 9. 本地缓存

### 10. CDN

#### 10.1 概念

>个人理解：有一个人前去买煎饼，来回路程花费了2小时，**往返时间就被称之为RTT**（Round-Trip Time）。煎饼店为了满足粉丝顾客的需求，开了很多的分店，开到接近用户的位置，这些分店形成了**内容分发网络**（CDN），每个分店相当于边缘服务器提供各类服务，可以让用户方便的买到煎饼，而不是消耗时间。分店向总店（源服务器）请求各类煎饼的配方（静态资源），就可以直接把不同种类的煎饼卖给用户了。当用户请求了一个新配方的煎饼，当前分店没有，分店再向总店请求这个配方，拿到配方后卖给用户吃。此后，所有来的顾客都可以买到新配方的煎饼了。

CDN（Content Delivery Network，内容分发网络）是指一种通过互联网互相连接的电脑网络系统，利用**最靠近每位用户的服务器**，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。源服务器可以通过HTTP头部的`cache-control`（可以设置文件的缓存形式），告知CDN，哪些资源可以保存，哪些资源不需要保存，文件保存多久等。

典型的CDN系统由下面三个部分组成：

- 分发服务系统：最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、服务能力是衡量一个CDN系统服务能力的最基本的指标。（煎饼店拥有的配方数量，可以同时容纳顾客的数量等性能）
- 负载均衡系统：主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本地负载均衡（SLB）。全局负载均衡主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。本地负载均衡主要负责节点内部的设备负载均衡（当前分店的人流量达到峰值后，导航帮助用户指向最近的其他煎饼店）
- 运营管理系统：运营管理系统分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。

#### 10.2 作用

CDN一般会用来托管Web资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。使用CDN来加速这些资源的访问。

（1）在性能方面，引入CDN的作用在于：

- 用户收到的内容来自最近的数据中心，延迟更低，内容加载更快

- 部分资源请求分配给了CDN，减少了服务器的负载

（2）在安全方面，CDN有助于防御DDoS、MITM等网络攻击：

- 针对DDoS：通过监控分析异常流量，限制其请求频率

- 针对MITM：从源服务器到 CDN 节点到 ISP（Internet Service Provider），全链路 HTTPS 通信
  除此之外，CDN作为一种基础的云服务，同样具有资源托管、按需扩展（能够应对流量高峰）等方面的优势。

<img src="C:\Users\SFONE\AppData\Roaming\Typora\typora-user-images\image-20220706163732365.png" alt="image-20220706163732365" style="zoom:67%;" />

#### 10.3 原理

**1）用户未使用CDN缓存资源的过程：**

1. 浏览器通过DNS对域名进行解析（就是上面的DNS解析过程），依次得到此域名对应的IP地址
2. 浏览器根据得到的IP地址，向域名的服务主机发送数据请求
3. 服务器向浏览器返回响应数据

**2）用户使用CDN缓存资源的过程：**

1. 对于点击的数据的URL，经过本地DNS系统的解析，发现该URL对应的是一个CDN专用的DNS服务器，DNS系统就会将域名解析权交给CNAME指向的CDN专用的DNS服务器。
2. CDN专用DNS服务器将CDN的全局负载均衡设备IP地址返回给用户
3. 用户向CDN的全局负载均衡设备发起数据请求
4. CDN的全局负载均衡设备根据用户的IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求
5. 区域负载均衡设备选择一台合适的缓存服务器来提供服务，将该缓存服务器的IP地址返回给全局负载均衡设备
6. 全局负载均衡设备把服务器的IP地址返回给用户
7. 用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。

如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。

#### 10.4 使用场景

- **使用第三方的CDN服务：**如果想要开源一些项目，可以使用第三方的CDN服务
- **使用CDN进行静态资源的缓存**：将自己网站的静态资源放在CDN上，比如js、css、图片等。可以将整个项目放在CDN上，完成一键部署。
- **直播传送**：直播本质上是使用流媒体进行传送，CDN也是支持流媒体传送的，所以直播完全可以使用CDN来提高访问速度。CDN在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。

### 性能监控

### 性能工具

### 11. DOM优化

#### documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？

MDN中对documentFragment的解释：

>DocumentFragment，文档片段接口，一个没有父对象的最小文档对象。它被作为一个轻量版的 Document使用，就像标准的document一样，存储由节点（nodes）组成的文档结构。与document相比，最大的区别是DocumentFragment不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。
>
>使用文档片段作为参数（例如，任何 [`Node`](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FNode) 接口类似 [`Node.appendChild`](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FNode%2FappendChild) 和 [`Node.insertBefore`](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FNode%2FinsertBefore) 的方法），这种情况下被添加（append）或被插入（inserted）的是片段的**所有子节点, 而非片段本身**。因为所有的节点会被一次插入到文档中，而这个操作仅发生一个重渲染的操作，而不是每个节点分别被插入到文档中，因为后者会发生多次重渲染的操作。

当我们把一个 `DocumentFragment` 节点插入文档树时，插入的不是 `DocumentFragment` 自身，而是它**的所有子孙节点**。在频繁的DOM操作时，我们就可以将DOM元素插入`DocumentFragment`，之后一次性的将所有的子孙节点插入文档中。和直接操作DOM相比，将`DocumentFragment` 节点插入DOM树时，不会触发页面的重绘，这样就大大提高了页面的性能。

### 12. 浏览器缓存

### 13. 服务端渲染

#### 13.1 客户端渲染

理解一：html 仅仅作为静态文件，客户端端在请求时，服务端不做任何处理，直接以原文件的形式返回给客户端客户端，然后根据 html 上的 JavaScript，生成 DOM 插入 html。

理解二：客户端渲染模式下，服务端把渲染的静态文件给到客户端，客户端拿到服务端发送过来的文件自己跑一遍js，根据JS运行结果，生成相应DOM，然后渲染给用户。客户端通过 HTTP 向服务器请求资源，当必要的资源都加载完毕后，执行 `new Vue()` 开始实例化并渲染页面。

优点： 网络传输数据量小、减少了服务器压力、前后端分离、局部刷新，无需每次请求完整页面、交互好可实现各种效果

缺点：不利于SEO、爬虫看不到完整的程序源码、首屏渲染慢（渲染前需要下载一堆js和css等）

#### 13.2 服务端渲染

理解：服务端渲染的模式下，当用户第一次请求页面时，服务器会查看当前路由组件需要哪些资源文件，然后将这些文件的内容填充到 HTML 文件，如果有 ajax 请求，就会执行它进行数据预取并填充到 HTML 文件里，最终渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码。使用服务端渲染的网站，可以说是“所见即所得”，页面上呈现的内容，我们在 html 源文件里也能找到。当客户端接收到这个 HTML 页面时，可以马上就开始渲染页面。与此同时，页面也会加载资源，当必要的资源都加载完毕后，开始执行 `new Vue()` 开始实例化并接管页面。总结下来就是，**服务端渲染的首屏加载块，有SEO优化**

优点:首屏渲染快、利于SEO、可以生成缓存片段，生成静态化文件、节能（对比客户端渲染的耗电）

坏处:用户体验较差、不容易维护，通常前端改了部分html或者css，后端也需要修改。

#### 13.3 对比

>其实前后端的渲染本质是一样的，都是字符串的拼接，将数据渲染进一些固定格式的html代码中形成最终的html展示在用户页面上。 因为字符串的拼接必然会损耗一些性能资源。

如果在服务器端渲染，那么消耗的就是server端的性能。 如果是在客户端渲染，常见的手段，比如是直接生成DOM插入到html 中，或者是使用一些前端的模板引擎等。他们初次渲染的原理大多是将原html中的数据标记（例如{{text}}）替换。

假设 A 网站页面中有一个关键字叫“前端性能优化”，这个关键字是 JS 代码跑过一遍后添加到 HTML 页面中的。那么客户端渲染模式下，我们在搜索引擎搜索这个关键字，是找不到 A 网站的——搜索引擎只会查找现成的内容，不会帮你跑 JS 代码。A 网站的运营方见此情形，感到很头大：搜索引擎搜不出来，用户找不到我们，谁还会用我的网站呢？为了把“现成的内容”拿给搜索引擎看，A 网站不得不启用服务端渲染。 但性能在其次，不代表性能不重要。服务端渲染解决了一个非常关键的性能问题——首屏加载速度过慢。在客户端渲染模式下，我们除了加载 HTML，还要等渲染所需的这部分 JS 加载完，之后还得把这部分 JS 在浏览器上再跑一遍。这一切都是发生在用户点击了我们的链接之后的事情，在这个过程结束之前，用户始终见不到我们网页的庐山真面目，也就是说用户一直在等！相比之下，服务端渲染模式下，服务器给到客户端的已经是一个直接可以拿来呈现给用户的网页，中间环节早在服务端就帮我们做掉了，用户岂不“美滋滋”？处。

#### 13.4 什么情况下使用服务端渲染？

通过服务端渲染的概念以及它的两个特点：`首屏加载速度快`、`SEO优化`。 我们知道，服务端渲染其实就是`由浏览器做的一些事情，我们放到了服务端去做`，那么对于掘金、简书、CSDN、知乎等网站的搭建，这种在网上一搜搜出一堆东西的网站，SEO做的很好，应该多少都用到服务端渲染了吧？当然，做服务端渲染成本是高昂的。 vue全家桶或者react全家桶，都是推荐通过服务端渲染来实现路由的。 服务端渲染并非完全之策（服务器稀少而宝贵），关于首屏渲染体验以及SEO的优化方案很多，在不使用服务端渲染这个操作下，我们最好的处理方式就是找寻替代优化方案。

关于在server端还是在browser端渲染的选择，更多的是要看业务场景。

### 14.Webpack优化

**任播**

### 15. SEO搜索优化

>背景：一个关键词对用多个网址，因此就出现了排序的问题，相应的当与关键词最吻合的网址就会排在前面了。在“蜘蛛”抓取网页内容，提炼关键词的这个过程中，就存在一个问题：“蜘蛛”能否看懂。如果网站内容是flash和js等，那么它是看不懂的，会犯迷糊，即使关键字再贴切也没用。相应的，如果网站内容可以被搜索引擎能识别，那么搜索引擎就会提高该网站的权重，增加对该网站的友好度。这样一个过程我们称之为SEO。

一：HTML结构方面

- 对于标题等重要标签，h1等自带权重，利于SEO，所以不得乱用h标签，合理的设置title、description和keywords
- 图片`img`标签添加`alt`和`title`属性，及时图片未能正常显示时，用户也能看到提示文字。
- 页内链接，要加 “title” 属性加以说明，让访客和 “蜘蛛” 知道。而外部链接，链接到其他网站的，则需要加上 el="nofollow" 属性, 告诉 “蜘蛛” 不要爬，因为一旦“蜘蛛”爬了外部链接之后，就不会再回来了。
- 重要内容不要放在js中，因为“蜘蛛”不会读取js中的内容，重要内容应放在HTML中，并且重要内容应该在HTML中的前部。HTML的结构应该遵循**语义化**
- 尽量少使用iframe框架，因为“蜘蛛”一般不会读取里面的内容
- 谨慎使用display:none。搜索引擎会过滤掉其中的内容，可以使用z-index或缩进设置为负值偏离浏览器
- 网站的结构要扁平。结构层数越少越好，一般不要超过三层，搜索引擎一般到了第三层就不想继续深入地爬取了。多数的网站，例如掘金、雪球等，他们的网站结构是两层，他们的首页和频道页是同一个页面。
- 页面应该要有简明的导航。导航可以让搜索引擎知道网站的结构，也可以让搜索引擎知道当前页面在网站结构所在的层次。
- 规范的URL：规范、简单、易理解的URL能让搜索引擎更好地抓取内容
- 控制首页连接数量：网站首页是权重最高的地方，如果首页链接太少，没有“桥”，“蜘蛛”不能继续往下爬到内页，直接影响网站收录数量。但是首页链接也不能太多，一旦太多，没有实质性的链接，很容易影响用户体验，也会降低网站首页的权重，收录效果也不好。
- 控制页面的大小，减少http请求，提高网站的加载速度。一个页面最好不要超过100k，太大，页面加载速度慢。当速度很慢时，用户体验不好，留不住访客，并且一旦超时，“蜘蛛”也会离开。

二：VUE项目中

- 服务端渲染（Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染），

- Vue单页项目的SEO

  目前，对于SEO支持比较好的项目方案是采用服务端渲染。所以如果项目有SEO需求，那么比较好的方案是服务端渲染。

  如果你已经采用了前后分离的单页项目，而你的网站内容不需要AJAX去获取内容和展示内容，那么可以试试 [prerender-spa-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fchrisvfritz%2Fprerender-spa-plugin) 这个插件，这个插件是一个webpack插件，可以帮助你在打包过程中通过无头浏览器去渲染你的页面，并生成对应的HTML。当然这个方案适合你的路由是静态的，并且路由数量是有限的。

  如果你的内容是AJAX动态获取的，那么vue单页项目可以试试 [prerender](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fprerender%2Fprerender) ,这个是一个预渲染服务，可以帮你通过无头浏览器渲染页面，并返回HTML。这个方案和`prerender-spa-plugin`很相似，都是通过无头浏览器去渲染页面，不同的是渲染的时机，`prerender-spa-plugin`是在打包过程中渲染，注定了其只能渲染静态路由，而`prerender` 是在请求时渲染，所以可以渲染动态的路由。

### 16.VUE首屏优化

## 六、前端设计模式

### 1. 单例模式

### 2. 工厂模式

### 3. 原型模式

### 4. 状态模式

### 5. 策略模式

### 6. 代理模式

### 7. 装饰器模式

### 8. 适配器模式

### 9. 迭代器模式

### 10. 观察者模式/发布订阅模式