<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>浅拷贝与深拷贝</title>
</head>
<body>

</body>
<script>
    let target = { a:1 }
    let source1 = { b:2 }
    let source2 = { c:3 }
    let arr =[1,3,4,5]
    //-------------------浅拷贝---------------------------------
    //1.Object.assign
    console.log(  Object.assign(target,source1,source2))

    //2.扩展运算符
    let newobj = {...target,...source1,...source2}
    console.log(newobj)

    //3.数组的原型方法slice，用于返回指定序列之间的元素
    let newarr1 = arr.slice()   //空值默认不删除，不增加任何元素
    console.log(newarr1)

    //4. 数组的原型方法concat，用于合并两个或多个数组
    let newarr2 = arr.concat()
    console.log(newarr2)

    //5.手写实现浅拷贝
    function shallowCopy(object) {
        //如果传入参数为空，或是基本数据类型，则直接返回
        if(typeof object !== "object" || !object) return ;

        let newObject = Array.isArray(object) ? [] :{}  //如果是数据类型，则新建[]，反之则新建{}
        //遍历object，当是object的属性才拷贝
        for( let key in object){
            if(object.hasOwnProperty(key)){   //用来判断一个属性是定义在对象本身而不是继承自原型链的。
                newObject[key] = object[key]
            }
        }
        return newObject
    }

    //--------------------深拷贝--------------------------------
    // 1. Json.stringify属性，可以将js对象序列化（Js对象转换为json字符串），再使用Json.parse来反序列化，还原js对象
    // 这个方法可以简单粗暴的实现深拷贝，但是还存在问题，拷贝的对象中如果有函数，undefined，symbol，
    // 当使用过JSON.stringify()进行处理之后，都会消失。
    let obj1 = {
        a:1,
        b:2,
        c:{
            left:1,
            right:2
        }
    }
    obj1.b.left = 'left'
    let obj2 = JSON.stringify(obj1)
    console.log(obj2)   //b.left没有被修改为left

    //手写深拷贝
    function deepCopy(object) {
        if(typeof object !== 'object' || !object){
            return ;
        }
        let newObj = Array.isArray(object) ? []:{}
        for( let  key in object){
            if ( object.hasOwnProperty(key)){   //递归遍历，如果还包含对象，则继续遍历，反之则直接返回
                newObj[key] = typeof object[key] === 'object' ? deepCopy(object[key]) : object[key]
            }
        }
        return newObj

    }



</script>
</html>