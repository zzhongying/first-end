<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script>
    function runAsync (x) {
        const p = new Promise(r => setTimeout(
            () => r(x, console.log(x)
            ), 1000)
        )
        return p
    }
    function runReject (x) {
        const p = new Promise((res, rej) => setTimeout(
            () => rej(`Error: ${x}`, console.log(x)),
            1000 * x)
        )
        return p
    }
    Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
        .then(res => console.log(res))
        .catch(err => console.log(err))

    // 1s后输出
   // 1
    //3
    // 2s后输出
   // 2
   // Error: 2
    // 4s后输出
   // 4

    //可以看到。catch捕获到了第一个错误，在这道题目中最先的错误就是runReject(2)的结果。
    // 如果一组异步操作中有一个异常都不会进入.then()的第一个回调函数参数中。会被.then()的第二个回调函数捕获。
</script>
</html>