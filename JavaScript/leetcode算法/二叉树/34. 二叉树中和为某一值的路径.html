<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>34.二叉树中和为某一值的路径</title>
</head>
<body>

</body>
<script>
    function Node(data,left,right){
        this.data = data;
        this.left = left;
        this.right = right;
    }
    function BST(){
        this.root = null;
        this.insert = insert;
    }
    /*
    * parameter: data:本节点的数据；
    * 创建节点示例并插入到二叉树的正确位置
    */
    function Node(data,left,right){
        this.data = data;
        this.left = left;
        this.right = right;
    }
    function BST(){
        this.root = null;
        this.insert = insert;
    }
    function insert(data){
        var node = new Node(data,null,null);
        if(this.root == null){
            this.root = node;
        }else{
            var current = this.root;
            while(true){
                if(current.data > data){
                    if(current.left === null){
                        current.left = node;
                        break;
                    }
                    current = current.left;
                }else{
                    if(current.right === null){
                        current.right = node;
                        break;
                    }
                    current = current.right;
                }
            }
        }
    }
    var bst = new BST();
    bst.insert(5);
    bst.insert(3);
    bst.insert(7);
    bst.insert(2);
    bst.insert(6);
    bst.insert(8);

    console.log(bst)
    // 注：题目要求必须是根节点到叶子节点，不能为中途节点
    var pathSum = function(root, target) {
        let result = []
        let path = []
        function pathFound(root,target,count){
            if(root == null) return [];
            // 节点一进来就加和 并且将节点数据放到路径数组中
            count += root.val
            path.push(root.val)
            if(target == count && root.left == null && root.right == null){
                // 加和符合条件的前提下当前这个节点必须是叶子节点
                // 同时满足这两个条件 创建新数组 并且将新的数组放进结果数组中
                result.push([...path])
            }
            pathFound(root.left,target,count)
            pathFound(root.right,target,count)
            // 没彻底执行完一次函数 就将数组中的最后一个数据弹出
            // 保持数组中的数据实时更新 才能在符合条件的时候直接赋值给新数组，并且压入结果数组
            path.pop()
        }
        pathFound(root,target,0)
        return result

    }

    // var arr1=[1,2,3]
    // var arr2 = []
    // arr2.push(...arr1)     //[1,2,3] 相当于深拷贝拷贝数组

</script>
</html>